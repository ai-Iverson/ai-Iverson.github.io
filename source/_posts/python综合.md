---
title: python综合
author: zhangxin
tags:
  - private
  - python
date: 2023-08-17 14:01:13
categories: python
---

#### python的数据类型

int,str,set,list,dict,tuple,float

**可变类型**:可以进行修改,修改后物理地址不发生改变,内部元素发生变化,外部对象不变

	-  list
	-  set
	-  dict

**不可变类型:**不可以进行修改,修改后变为一个新的对象,物理地址发生改变,内部元素不可修改

id(object) 可以查看对象的 是否发生改变



#### dict的key

字典的key和value是一一对应的,所以key需要满足哈希算法的,可变的数据类型是不可以当key的

字典的查询,删除,添加的平均时间复杂度都是O(1), 相比列表与元组,性能更优.

python3.6之前的是无序字典

	-  字典底层维护了一张哈希表,哈希表中每一个元素存储了,哈希值hash,键key,值value

python3.7含之后是有序的

	- 两张表 一个空表(enteies)存储哈希值hash键key值value, 一个列表(indices)存储位置信息index
 - 取值的顺序:
   - dict([key])
   - Hash_value = hash(key)  计算键的哈希值
   - index = hash_value&(Len(indices)-1)  
   - entey_index = indices[index]   index指向enteies中的位置
   - value = enteies[entey_index]

字典的平均时间复杂度是O(1),因为字典是通过哈希算法来实现的,哈希算法不可避免的问题就是hash冲突,python字典发生哈希冲突时,会向下寻找空余位置,直到找到位置.如果在计算key的hash的值时,如果一直找不到空余位置,则字典的时间复杂度就变成了O(n)了



#### 哈希算法

哈希算法又称摘要算法,作用时对任意输入数据进行计算,得到一个固定长度的输出摘要

哈希算法的特点:

- 相同的输入一定的到相同的输出
- 不同的输入大概率得到不同的输出

哈希算法的目的就是验证原始数据是否被篡改



#### python字典哈希冲突问题

- python字典检查两个值是否相等,是比较两个值的哈希值是否相等

- 具有不同值的对象也有可能hash值一样,比如:hash(5)和hash(5.0) 称为哈希冲突

- 哈希冲突的解决办法:

  - 开放寻址法:
    - 从发生碰撞的单元起,按照一定的顺序,从哈希表中寻找一个空闲单元,存放发生碰撞的元素,这个空闲的单元又称为空白单元,或开放单元
    - 开放寻址法现象成一个找车位的问题,如果当前车位有车了就继续往前走,去找下一个空的停车位
    - 方法1: 线性探测法,顺序查找每一个空位,直到找到空位,每次步长为1
    - 方法2: 二次探查,在表的左右位置根据一定的步长进行跳跃探索,每次步长为n
    - 方法3: 伪随机探测,根据公式生成一个随机数,步长以这个随机数为准进行探测
  - 再哈希法:
    - 就是换个哈希函数继续计算,可能还会造成冲突,多准备几个哈希函数
  - 链地址法:
    - 就是把哈希值相同的值放到同一个链表再挨个查,优点是不同的哈希值不会冲突

  - 公共溢出区:
    - 把所有冲突的放在一个特定的溢出区,去那里找



#### 装饰器

实质上也是一个闭包函数,也是一个嵌套函数

作用:

- 在不改变原函数的情况下,对已有函数进行额外的功能扩展

条件:

- 不修改已有函数的源代码
- 不修改已有函数的调用方式
- 给已有函数增加额外的功能

与闭包的区别:

- 参数有且只有一个,并且是函数类型



#### 闭包

闭包就是能够读取其他函数内部变量的函数

作用:

- 保存外部函数的变量,不会随着外部函数调用而销毁

条件:

- 函数嵌套
- 内部函数必须使用了外部函数的变量或参数
- 外部函数返回内部函数,这个使用了外部函数变量的内部函数称为闭包



#### 函数与方法的区别

- 函数是独立的代码块,用于完成独立的任务
- 方法是类中的函数,用于描述类的行为



#### 对象是什么

- 地址 id()
- 类型 type()
- 值 value()



#### 类的继承顺序

- mro()算法



#### GC垃圾回收

引用计数是python的必需功能,分代回收可选(gc.disable 禁用分代回收),gc.collect()手动触发对象回收

- 引用计数
  - 如果没有变量引用某一对象,这个对象就会被回收,python中的每个变量都是对对象的引用,而不是对象本身
  - 核心概念: 变量是指向一个对象的指针,有n个变量指向一个对象,那么该对象的引用计数则为n,又称该对象有n个引用
  - id(变量名)可以查看变量指向的对象的地址, sys.getrefcount(object) 查看引用计数,但是当调用sys.getrefcount()时会临时增加一次引用
  - 缺点: 循环引用,线程锁定以及额外内存和性能开销,循环引用问题会造成内存泄漏
- 分代回收
  - 专门解决循环引用的问题

​	

引用计数实时作用, 循环引用的回收是定期运行的,垃圾回收器将container对象分为三代,每个新对象都从第一代开始,如果一个对象在一个垃圾回收轮次中幸存下来,它将移至较旧(更高)的一代,较低代的回收效率高于较高代,因为大多数新对象往往会被先销毁,这样分代回收的策略能提高性能并减少垃圾回收带来的暂停时间

每一代都有一个独立的计数器和阈值,计数器存储上次收集以来的对象分配数减去释放数的差值,每次分配新的对象容器对象时,cPython都会检查第0代的计数器是否超过阈值(通过gc.get_count()获得三代对象计数器存储的数值),如果超过阈值,python将触发垃圾回收,



#### python对象的生命周期和方法

__ new __ 创建对象

__ init __ 初始化对象

__ del __ 回收、删除对象



#### GIL锁

GIL全局解释器锁,是一个互斥锁,锁是python解释器的而不是python本身的,防止多线程同时执行python的字节码,防止多线程同时访问python对象.GIL锁用来保护指向当前进程状态的指针.



多个线程同时对一个数据进行增加或减少操作,可能导致内存泄漏(引发数据不一致)



一个对象一把锁带来的问题:

- 死锁: 线程之间相互竞争抢锁的资源
- 反复获取和解释锁导致性能降低



GIL锁规则: 任何python字节码的执行都需要获取解释器锁,这样可以防止死锁,并且带来的性能开销不大,但这实际上使所有受cpu约束的python程序(cpu密集型)都是单线程



线程释放GIL锁的两种情况:

- 遇到IO操作
  - 发送一个http请求等,等待响应
  - 当前执行的线程释放后,不再参与锁的抢夺
- time tick到期
  - time tick规定了线程最长执行时间,超过时间后自动释放GIL锁,间隔大致15毫秒
  - 当前执行的线程释放后(多数是cpu密集型任务),继续参与锁的抢夺



单核cpu下 cpu的利用率很高

多核cpu下由于GIL锁的全局特性,无法发挥多核的特性,GIL锁会使的多线程任务的效率大大降低

GIL降低了多核的效率,保留的目的是线程执行的安全问题

