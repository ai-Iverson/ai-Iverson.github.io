---
title: 设计模式
author: zhangxin
tags:
  - private
  - 设计模式
date: 2023-07-31 15:10:11
categories: python
---

### 单例设计模式

**单例设计模式的意图:**

- 确保类有且只有一个对象被创建

- 为对象提供一个访问点,以使程序可以全局访问该对象

- 控制共享资源的并行访问

  

**经典的python单例模式**

- 只允许Singleton类生成一个实例
- 如果已经有一个实例了,我们会重复提供同一个对象

```python
class Singleton(object):
    def __new__(cls):
        if not hasattr(cls, 'instance'):
            # 如果没有instance属性,就添加
            cls.instance = super(Singleton, cls).__new__(cls)
        return cls.instance


s = Singleton()
print("Object created", s)

s1 = Singleton()
print("Object created", s1)

# 结果
Object created <__main__.Singleton object at 0x105133340>
Object created <__main__.Singleton object at 0x105133340>
```



**单例模式中的懒汉式实例化**

懒汉式实例化能够确保在实际需要时才创建对象,执行s = singleton()的时候,会调用__init__方法,但没有新的对象被创建,对象调用发生在调用Singleton.getInstance()的时候

```python
class Singleton:
    __instance = None

    def __init__(self):
        if not Singleton.__instance:
            print(" __init__ method called..")
        else:
            print("Instance already created:", self.getInstance())

    @classmethod
    def getInstance(cls):
        if not cls.__instance:
            cls.__instance = Singleton()
        return cls.__instance


s = Singleton()
print("Object created", Singleton.getInstance())
```



**装饰器实现单例模式**

函数装饰器

```python
def singleton(cls):
    _instance = {}
    def decorated(*args, **kwargs):
        if cls not in _instance:
            _instance[cls] = cls(*args, **kwargs)
        return _instance[cls]
    return decorated


@singleton
class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age
```

**类装饰器**

```python
class Singleton(object):
    def __init__(self,cls):
        self._cls = cls
        self._instance = {}

    def __call__(self, *args):
        if self._cls not in self._instance:
            self._instance[self._cls] = self._cls(*args)
        return self._instance[self._cls]

@Singleton
class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age
```



**元类metaclass实现的单例**

```python
class Singleton(type):
    def __call__(cls, *args, **kwargs):
        if not hasattr(cls, "_instance"):
            cls._instance = super().__call__(*args, **kwargs)
        return cls._instance


class Person(metaclass=Singleton):
    def __init__(self,name, age):
        self.name = name
        self.age = age
```



**单例模式的缺点**

- 全局变量可能在某处已经被误改,但是开发人员仍然认为它们没有发生变化,而该变量还在应用程序的其他位置被使用
- 可能会对同一个对象创建多个引用.由于单例只创建一个对象,因此这种情况下会对同一个对象创建多个引用.
- 所有依赖于全局变量的类都会由于一个类的改变而紧密耦合为全局数据,从而在无意中影响到另一个类.



### 工厂模式

- 松耦合,即对象的创建可以独立于类的实现.
- 客户端无需了解创建对象的类,但是照样可以使用它来创建对象.它只需要知道需要传递的接口,方法和参数,就能够创建所需类型的对象了.这就简化了客户端的实现
- 可以轻松地在工厂中添加其他类来创建其他类型的对象,而这无需更改客户端代码.最简单的情况下,客户端只需要传递另一个参数就可以了.
- 工厂还可以重用现有对象.但是,如果,客户端直接创建对象的话,总是创建一个新对象.

**简单工厂模式** 

```PYTHON
from abc import ABCMeta, abstractmethod


class Section(metaclass=ABCMeta):
    @abstractmethod
    def describe(self):
        pass


class PersonalSection(Section):
    def describe(self):
        print("Personal Section")


class AlbumSection(Section):
    def describe(self):
        print("Album Section")


class PatentSection(Section):
    def describe(self):
        print("Patent Section")


class PublicationSection(Section):
    def describe(self):
        print("Publication Section")


class Profile(metaclass=ABCMeta):
    def __init__(self):
        self.sections = []
        self.createProfile()

    @abstractmethod
    def createProfile(self):
        pass

    def getSections(self):
        return self.sections

    def addSections(self, section):
        self.sections.append(section)


class linkedin(Profile):
    def createProfile(self):
        self.addSections(PersonalSection())
        self.addSections(PatentSection())
        self.addSections(PublicationSection())


class facebook(Profile):
    def createProfile(self):
        self.addSections(PersonalSection())
        self.addSections(AlbumSection())


if __name__ == '__main__':
    profile_type = input("Which Profile you'd like to create?[LinkedIn or FaceBook]")
    profile = eval(profile_type.lower())()
    print("Creating Profile..", type(profile).__name__)
    print("Profile has sections --", profile.getSections())

```



**抽象工厂模式**

```python
from abc import ABCMeta, abstractmethod


class PizzaFactory(metaclass=ABCMeta):
    """披萨基类"""

    @abstractmethod
    def createVegPizza(self):
        pass

    @abstractmethod
    def createNonVegPizza(self):
        pass


class IndianPizzaFactory(PizzaFactory):
    """印式披萨工厂类"""

    def createVegPizza(self):
        return DeluxVeggiePizza()

    def createNonVegPizza(self):
        return ChickenPizza()


class USPizzaFactory(PizzaFactory):
    """美式披萨工厂类"""

    def createVegPizza(self):
        return MexicanVegPizza()

    def createNonVegPizza(self):
        return HamPizza()


class VegPizza(metaclass=ABCMeta):
    """素食披萨基类"""
    @abstractmethod
    def prepare(self, VegPizza):
        pass


class NonVegPizza(metaclass=ABCMeta):
    """非素食披萨基类"""
    @abstractmethod
    def serve(self, VegPizza):
        pass


class DeluxVeggiePizza(VegPizza):
    """豪华素食披萨类"""
    def prepare(self):
        print("Prepare ", type(self).__name__)


class ChickenPizza(NonVegPizza):
    """鸡肉披萨类"""
    def serve(self, VegPizza):
        print(type(self).__name__, " is served with Chicken on ",
              type(VegPizza).__name__)


class MexicanVegPizza(VegPizza):
    """墨西哥蔬菜披萨类"""
    def prepare(self):
        print("Prepare ", type(self).__name__)


class HamPizza(NonVegPizza):
    """火腿披萨类"""
    def serve(self, VegPizza):
        print(type(self).__name__, " is served with Ham on ",
              type(VegPizza).__name__)


class PizzaStore:
    """披萨工厂"""
    def __init__(self):
        pass

    def makePizzas(self):
        for factory in [IndianPizzaFactory(), USPizzaFactory()]:
            self.factory = factory
            self.NonVegPizza = self.factory.createNonVegPizza()
            self.VegPizza = self.factory.createVegPizza()
            self.VegPizza.prepare()
            self.NonVegPizza.serve(self.VegPizza)


pizza = PizzaStore()
pizza.makePizzas()
```



### 门面模式

- 它为子系统中的一组接口提供一个统一的接口,并定义一个高级接口来帮助客户端通过更加简单的方式使用子系统.
- 门面所解决的问题是,如何用单个接口对象来表示复杂的子系统.实际上,它并不是封装子系统,而是对底层子系统进行组合.
- 它促进了实现与多个客户端的解耦

![image-20230802160632848](https://raw.githubusercontent.com/zxinyolo/images/main/202308021606925.png)

```python
class EventManager(object):
    """婚礼筹备门面"""

    def __init__(self):
        print("Event Manager:: Let me talk to the folks\n")

    def arrange(self):
        self.hotelier = Hotelier()
        self.hotelier.bookHotel()

        self.florist = Florist()
        self.florist.setFlowerRequirements()

        self.caterer = Caterer()
        self.caterer.setCuisine()

        self.musician = Musician()
        self.musician.setMusicType()


class Hotelier(object):
    """预定酒店"""

    def __init__(self):
        print("Arranging the Hotel for Marriage? --")

    def __isAvailable(self):
        print("Is the Hotel free for the event on given day?")
        return True

    def bookHotel(self):
        if self.__isAvailable():
            print("Registered the Booking\n\n")


class Florist(object):
    """花卉装饰"""

    def __init__(self):
        print("Flower Decorations for the Event? --")

    def setFlowerRequirements(self):
        print("Carnations, Roses and Lilies would be used for Decorations\n\n")


class Caterer(object):
    """备办宴席"""

    def __init__(self):
        print("Food Arrangements for the Event --")

    def setCuisine(self):
        print("Chinese & Continental Cuisine to be served\n\n")


class Musician(object):
    """婚礼音乐"""

    def __init__(self):
        print("Musical Arrangements for the Marriage --")

    def setMusicType(self):
        print("Jazz and Classical will be played\n\n")


class You(object):
    def __init__(self):
        print("You:: Whoa! Marriage Arrangements??!!!")

    def askEventManager(self):
        print("You:: Let's Contact the Event Manager\n\n")
        em = EventManager()
        em.arrange()

    def __del__(self):
        print("You:: Thanks to Event Manager, all preparations done! Phew!")


you = You()
you.askEventManager()
```

